# 稳定子编码

本文希望简要介绍量子纠错中的稳定子编码框架。

## 最简单的编码：5-qubit Code

在系统介绍稳定子之前，我们首先来看一个最简单的例子，即 5-qubit code。这里我们考虑由 5 个 qubit 组成的体系，并给出定义在其上的 4 个算符：
$$
\begin{eqnarray}
    g_1 &=& XZZXI, \\
    g_2 &=& IXZZX, \\
    g_3 &=& XIXZZ, \\
    g_4 &=& ZXIXZ,
\end{eqnarray}
$$
其中我们用字母 $\{I,X,Y,Z\}$ 代表泡利算符，并忽略了直积符号。首先我们可以验证，这 4 个算符两两对易：$[g_i,g_j] = 0$，因此它们能决定共同本征态。我们考虑这样的态，是每个泡利算符本征值为 1 的本征态：
$$
g_i |\psi\rangle = |\psi\rangle.
$$
我们现在可以问，满足上式的态构成几维空间。为了更容易看出这一点，引入第 5 个算符：
$$
\bar Z = ZZZZZ,
$$
满足 $[\bar Z, g_i]=0$，此时 5 个相互对易算算符按它们的本征值给出了希尔伯特空间的完备基 $\{|\vec n\rangle \}$：我们可以找到 $2^5=32$ 个正交的态，每个态由算符集 $\{g_i, \bar Z\}$ 的本征值 $\pm 1$ 标记：
$$
|\vec n\rangle=|g_i = n_i, \bar Z = n_5\rangle,\ n_i=\pm 1.
$$
相应地，由 4 算符 $\{g_i\}$ 确定的本征值都为 1 的态构成了 2 维子空间，算符 $\bar Z$ 取 $\pm 1$ 的两个态继续给了这个子空间一组基：
$$
\begin{eqnarray}
  |+\rangle &=& |g_i=1,\bar Z = +1\rangle, \\
  |-\rangle &=& |g_i=1,\bar Z = -1\rangle.
\end{eqnarray}
$$
上述这种通过一组泡利算符来给出特定子空间的框架被称为稳定子编码，相应的，算符 $g_i$ 称为稳定子。

应用上，我将这个 2 维子空间视作一个被编码的 logic qubit，而储存它的 5 个 qubit 则称为 physical qubit。这样的编码方式需要更多的 qubit，但这种数量的冗余可以提高系统的容错性。对于 5-qubit code 而言，在一个 qubit 上发生的任意错误都不会破坏被编码的信息：我们甚至只需要拿其中任意 4 个 qubit，就能读出编码信息。另外，当我们已知系统的稳定子时，我们可以在剩余自由度上选取一组逻辑操作 $\{\bar Z, \bar X\}$，其中 $\bar Z$ 给出子空间的基地，$\bar X$ 用于改变 logic qubit，对于 5-qubit code,
$$
\bar X = XXXXX.
$$

## 稳定子编码的一般理论

现在考虑一般的稳定子编码。我们首先

## 从经典纠错码到量子纠错码：CSS Code

文字

## 线性码与多项式环

文字

## 纠错码的上界

文字

## References

